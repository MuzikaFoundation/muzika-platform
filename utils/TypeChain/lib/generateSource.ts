import { RawAbiDefinition, parse, Contract, AbiParameter } from "./abiParser";
import { getVersion } from "./utils";
import { EvmType } from "./typeParser";

export interface IContext {
  fileName: string;
  relativeRuntimePath: string;
  relativeInputPath: string;
}

export function generateSource(abi: Array<RawAbiDefinition>, context: IContext): string {
  const parsedContractAbi = parse(abi);

  return codeGenForContract(abi, parsedContractAbi, context);
}

// @todo better typings for web3
function codeGenForContract(abi: Array<RawAbiDefinition>, input: Contract, context: IContext) {
  const typeName = `${context.fileName}`;
  return `/* GENERATED BY TYPECHAIN VER. ${getVersion()} */
/* tslint:disable */
  
import * as contract from 'truffle-contract';
import { BigNumber } from 'bignumber.js';
import { EtherAddress, EtherInteger, ITxParams, RawAbiDefinition, TruffleContract, TruffleContractInstance, TxValue } from '${
    context.relativeRuntimePath
  }'
import BuiltContract from '${context.relativeInputPath}';

export interface I${typeName} extends TruffleContractInstance {
    
    ${input.constants
      .map(
        constant =>
          `${
            constant.name
          }(): Promise<${constant.output.generateCodeForOutput()}>;`,
      )
      .join("\n")} 
      ${input.constantFunctions
        .map(
          constantFunction =>
            `${constantFunction.name}(${constantFunction.inputs
              .map(codeGenForParams)
              .join(", ")}): Promise<${codeGenForOutputTypeList(
              constantFunction.outputs,
            )}>`,
        )
        .join(";\n")} 

        ${input.functions
          .map(func => {
            const params = func.inputs.map(codeGenForParams);
            const inputParams = params.join(", ");
            const inputParamsWithTxParam = [...params, 'txParams?: ITxParams'].join(", ");
            return `${func.name}: { (${inputParamsWithTxParam}): Promise<${codeGenForOutputTypeList(
              func.outputs,
            )}>, sendTransaction: (${inputParamsWithTxParam}) => Promise<${codeGenForOutputTypeList(
              func.outputs,
            )}>, call: (${inputParamsWithTxParam}) => Promise<${codeGenForOutputTypeList(
              func.outputs,
            )}>, request: (${inputParams}) => Promise<string>, estimateGas: (${inputParams}) => Promise<number> }`;
          })
          .join(";\n")} 
}

export const Truffle${typeName}: () => TruffleContract<I${typeName}> = () => contract(BuiltContract);`;
}

function codeGenForParams(param: AbiParameter, index: number): string {
  return `${param.name || `arg${index}`}: ${param.type.generateCodeForInput()}`;
}

function codeGenForArgs(param: AbiParameter, index: number): string {
  const paramName = param.name || `arg${index}`;
  return param.type.generateCodeForInputConversion(paramName);
}

function codeGenForOutputTypeList(output: Array<EvmType>): string {
  if (output.length === 1) {
    return output[0].generateCodeForOutput();
  } else {
    return `[${output.map(x => x.generateCodeForOutput()).join(", ")}]`;
  }
}
